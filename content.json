{"meta":{"title":"Shen的博客","subtitle":"","description":"纪录学习分享生活","author":"SH EN","url":"https://q7df1.github.io","root":"/"},"pages":[],"posts":[{"title":"jdk动态代理","slug":"jdk动态代理","date":"2023-07-21T13:27:49.000Z","updated":"2023-07-21T15:29:42.012Z","comments":true,"path":"2023/07/21/jdk动态代理/","link":"","permalink":"https://q7df1.github.io/2023/07/21/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"代理模式What is that代理模式是一种结构型设计模式，它允许通过创建一个代理对象来控制原始对象的访问。代理对象充当一个中介，通过在客户端和目标对象之间建立通信桥梁，帮助管理对目标对象的访问。代理类在接收到客户端的请求时，可以在执行具体操作之前或之后，对原始对象进行额外的处理，和如果我需要执行某段程序前想要输出日志，我不需要每次都将日志输出代码都写入代码块里，造成代码冗余。 How to use it1234567891011package shen.dao;import shen.entity.User;public interface IUserDao &#123; /* * 查找单个用户 * */ User findUserById(Integer id);&#125; 123456789101112131415package shen.dao.impl;import shen.dao.IUserDao;import shen.entity.User;public class UserDaoImpl implements IUserDao &#123; @Override public User findUserById(Integer id) &#123; User user = new User(0,&quot;you catch me&quot;,&quot;Hi&quot;); return user; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package shen.entity;public class User &#123; private Integer id; private String username; private String password; public User() &#123;&#125; public User(Integer id, String username, String password) &#123; this.id = id; this.username = username; this.password = password; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#x27;&quot; + username + &#x27;\\&#x27;&#x27; + &quot;, password=&#x27;&quot; + password + &#x27;\\&#x27;&#x27; + &#x27;&#125;&#x27;; &#125;&#125; 123456789101112131415161718192021222324package shen.handler;import shen.dao.IUserDao;import shen.dao.impl.UserDaoImpl;import shen.entity.User;public class ProxyHandler implements IUserDao &#123; public void before() &#123; System.out.println(&quot;turn on transaction&quot;); &#125; @Override public User findUserById(Integer id) &#123; this.before(); UserDaoImpl userDao = new UserDaoImpl(); User user = userDao.findUserById(id); System.out.println(user); this.after(); return user; &#125; public void after() &#123; System.out.println(&quot;turn off transaction&quot;); &#125;&#125; 123456789101112131415package shen.test;import shen.entity.User;import shen.handler.ProxyHandler;public class test &#123; public static void main(String[] args) &#123; IUserDao proxyHandler = new ProxyHandler(); proxyHandler.findUserById(0); &#125;&#125;```outputturn on transactionUser&#123;id=0, username=&#x27;You catch me&#x27;, password=&#x27;Hi&#x27;&#125;turn off transaction 通过这样静态代理实现接口的方式用proxyHandler实现获取User的同时还完成了after()，与before()两个方法 Why代理模式存在的原因是为了达到一些额外的目的，例如：提供一些额外的安全措施、控制对资源的访问、实现懒加载等。通过代理模式，我们可以灵活地管理和控制对目标对象的访问。 JDK动态代理What is that如果每个类都自己实现编写静态代理，不仅麻烦而且会导致程序非常复杂，这时可以用到JDK的动态代理API，JDK动态代理是一种特殊类型的代理模式，它允许在运行时动态生成代理类和代理对象。JDK动态代理需要使用Java的反射机制，利用代理类和InvocationHandler接口来实现代理功能。 How to use it在以上代码基础上对handler 包和test包进行更改 1234567891011121314151617181920212223242526272829303132333435package shen.handler;import shen.dao.IUserDao;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class DaoTransactionHandler implements InvocationHandler &#123;// if other class want use proxy you can choose Object class private Object obj; public DaoTransactionHandler(Object obj) &#123; this.obj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; Object res = null;// if you want to enhance just only one method if (&quot;findUserById&quot;.equals(method.getName())) &#123; this.before(); res = method.invoke(obj,args); this.after(); &#125;else &#123; res = method.invoke(args); &#125; return res; &#125; private void before() &#123; System.out.println(&quot;turn on enhance transaction&quot;); &#125; private void after()&#123; System.out.println(&quot;turn off enhance transaction&quot;); &#125;&#125; 123456789101112131415161718192021222324252627package shen.test;import shen.dao.IUserDao;import shen.dao.impl.UserDaoImpl;import shen.handler.DaoTransactionHandler;import java.lang.reflect.Proxy;public class test &#123; public static void main(String[] args) &#123;// target Class UserDaoImpl userDao = new UserDaoImpl();// enhance Class// invocation class DaoTransactionHandler daoTransactionHandler = new DaoTransactionHandler(userDao);// act proxy object IUserDao userDaoProxy =(IUserDao) Proxy.newProxyInstance(UserDaoImpl.class.getClassLoader(), UserDaoImpl.class.getInterfaces(), daoTransactionHandler); userDaoProxy.findUserById(0); &#125;&#125;```outputturn on enhance transactionUser&#123;id=0, username=&#x27;you catch me&#x27;, password=&#x27;Hi&#x27;&#125;turn off enhance transaction WhyJDK动态代理的好处在于，它不需要事先编写代理类的源代码，而是在运行时根据需要动态生成代理类和代理对象。这样可以大大简化开发过程，特别是当需要为多个类生成代理时，能够提高代码的灵活性和可维护性。 JDK动态代理的原理是利用了Java的反射机制，通过在运行时创建一个新的类，实现目标类所实现的接口，并在方法调用时使用InvocationHandler的实现类来处理额外逻辑。当代理对象的方法被调用时，JDK动态代理会通过反射将调用转发给InvocationHandler实例中的invoke()方法，从而实现代理功能。 可以集合JDK自动生成的$Proxy的源码分析： 修改test中代码可以生成$Proxy文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package shen.test;import shen.dao.IUserDao;import shen.dao.impl.UserDaoImpl;import shen.handler.DaoTransactionHandler;import sun.misc.ProxyGenerator;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;import java.lang.reflect.Proxy;public class test &#123; public static void main(String[] args) &#123;// target Class UserDaoImpl userDao = new UserDaoImpl();// enhance Class// invocation class DaoTransactionHandler daoTransactionHandler = new DaoTransactionHandler(userDao);// act proxy object IUserDao userDaoProxy =(IUserDao) Proxy.newProxyInstance(UserDaoImpl.class.getClassLoader(), UserDaoImpl.class.getInterfaces(), daoTransactionHandler); userDaoProxy.findUserById(0); // path such as &quot;C:\\\\IdeaProject\\\\proxyDemo\\\\src&quot; saveProxyClass(&quot;__your project path __\\\\src&quot;); &#125; //writing $proxy to contain in localhost private static void saveProxyClass(String path) &#123; byte[] $Proxy1s = ProxyGenerator.generateProxyClass(&quot;$Proxy1&quot;, UserDaoImpl.class.getInterfaces()); FileOutputStream out = null; try &#123; out = new FileOutputStream(new File(path + &quot;$Proxy1.class&quot;)); out.write($Proxy1s); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; if (out != null) &#123; try &#123; out.flush(); out.close(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; &#125;&#125; 分析源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public final class $Proxy1 extends Proxy implements IUserDao &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy1(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final User findUserById(Integer var1) throws &#123; try &#123; return (User)super.h.invoke(this, m3, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;)); m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;); m3 = Class.forName(&quot;shen.dao.IUserDao&quot;).getMethod(&quot;findUserById&quot;, Class.forName(&quot;java.lang.Integer&quot;)); m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; JDK动态代理的原理是利用了Java的反射机制，通过在运行时创建一个新的类，实现目标类所实现的接口，并在方法调用时使用InvocationHandler的实现类来处理额外逻辑。当代理对象的方法被调用时，JDK动态代理会通过反射将调用转发给InvocationHandler实例中的invoke()方法，从而实现代理功能。 以上就是我的理解!","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://q7df1.github.io/tags/Java/"}]},{"title":"range Pi R1 Plus LTS软路由打造","slug":"range-Pi-R1-Plus-LTS软路由打造","date":"2023-05-06T20:27:48.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/05/07/range-Pi-R1-Plus-LTS软路由打造/","link":"","permalink":"https://q7df1.github.io/2023/05/07/range-Pi-R1-Plus-LTS%E8%BD%AF%E8%B7%AF%E7%94%B1%E6%89%93%E9%80%A0/","excerpt":"","text":"香橙派打造软路由硬件介绍Orange Pi R1 Plus LTS（软路由）此产品定位即为了打造路由器官方参数如下： 官方自带有openwrt、ubuntu、debian固件等，but相信大家伙眼界没有受限于此 博主也建议选择社区版本openwrt固件这样优点很明显，能够拥有更多你想要的功能，废话不多说 固件引用官方固件 推荐固件(如果你与博主用的硬件一样请选择最后一个镜像下载) 安装固件需要条件：1、microSD卡（读卡器） 2、烧录工具 3、固件镜像文件 操作步骤：1、下载镜像文件、烧录工具 2、插入读卡器（microSD卡） 3、烧录系统（烧录好后千万不要格式化） 4、插上Pi 直接可以启动 启动路由器操作步骤1、连接电源，插上SD卡，连接lan网口至PC 2、PC检查网络连接找到IPv4 DNS服务器ip地址 3、浏览器访问该网址：默认为192.168.1.1 出现网站信息即成功！！！ 4、登录openwrt、账号：root、原版没有密码、lean大佬版本密码：password 祝你好运！！！ 附录编译固件想要自己diy插件功能等，可以自行编译固件，有详细教程，不需要编程知识，要求具备一定互联网搜索解决问题能力。 源码及编译教程地址 鸣谢感谢固件提供地址: 1https://openwrt.mpdn.fun:8443/?dir=lede/rockchip 感谢openwrt可编译源码 1https://github.com/coolsnowwolf/lede","categories":[],"tags":[{"name":"硬件","slug":"硬件","permalink":"https://q7df1.github.io/tags/%E7%A1%AC%E4%BB%B6/"}]},{"title":"初次模拟大数据","slug":"初次模拟大数据","date":"2023-03-29T17:00:42.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/03/30/初次模拟大数据/","link":"","permalink":"https://q7df1.github.io/2023/03/30/%E5%88%9D%E6%AC%A1%E6%A8%A1%E6%8B%9F%E5%A4%A7%E6%95%B0%E6%8D%AE/","excerpt":"","text":"模拟电商日志mapRuce计算准备环境ubuntu22.04虚拟机/物理机 jdk安装以及环境配置 maven安装以及环境配置 hadoop安装以及环境配置 日志信息模拟生成利用javaIO模拟生成100w条购买记录 1234567891011121314&amp;20320230401170400&amp;Larry&amp;虚拟产品&amp;68.0&amp;3.0&amp;204.0&amp;北京&amp;66420230401170400&amp;吴九&amp;电脑&amp;56.0&amp;13.0&amp;728.0&amp;北京&amp;90620230401170400&amp;郑十&amp;牙刷&amp;32.0&amp;9.0&amp;288.0&amp;北京&amp;60020230401170400&amp;郑十&amp;毛巾&amp;78.0&amp;1.0&amp;78.0&amp;长沙&amp;23020230401170400&amp;吴九&amp;虚拟产品&amp;61.0&amp;17.0&amp;1037.0&amp;长沙&amp;70520230401170400&amp;张三&amp;鞋子&amp;70.0&amp;15.0&amp;1050.0&amp;上海&amp;44620230401170400&amp;王五&amp;牙刷&amp;11.0&amp;7.0&amp;77.0&amp;上海&amp;18320230401170400&amp;赵六&amp;篮球&amp;48.0&amp;3.0&amp;144.0&amp;上海&amp;61620230401170400&amp;周八&amp;牙刷&amp;30.0&amp;19.0&amp;570.0&amp;上海......&amp;80320230401170400&amp;李四&amp;水杯&amp;19.0&amp;9.0&amp;171.0&amp;北京&amp;48620230401170400&amp;周八&amp;牙刷&amp;97.0&amp;9.0&amp;873.0&amp;张家界&amp;43120230401170400&amp;张三&amp;篮球&amp;36.0&amp;6.0&amp;216.0&amp;佛山&amp;93720230401170400&amp;李四&amp;毛巾&amp;56.0&amp;19.0&amp;1064.0&amp;广州 构建maven项目项目结构：将hadoop&#x2F;etc&#x2F;hadoop目录下的core-site.xml,hdfs-site.xml,log4g.properties文件分别复制到resources目录下 修改pom.xml 配置文件(博主用的Hadoop2.10.1，jdk1.8 maven3.9) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mapReduceDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;apache&lt;/id&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-jobclient&lt;/artifactId&gt; &lt;version&gt;2.10.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 计算每个城市对应的购买总金额，accountByCity.java代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.FileSystem;import org.apache.hadoop.fs.Path;//import org.apache.hadoop.io.IntWritable;import org.apache.hadoop.io.LongWritable;import org.apache.hadoop.io.Text;import org.apache.hadoop.mapreduce.Job;import org.apache.hadoop.mapreduce.Mapper;import org.apache.hadoop.mapreduce.Reducer;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import java.io.IOException;import java.util.StringTokenizer;/** * &lt;城市，小计金额&gt; * * &lt;城市，&#123;小计金额，小计金额...&#125;&gt; * * &lt;城市，总计金额&gt; */public class accountByCity &#123; public static class myMapper extends Mapper&lt;Object,Text, Text, LongWritable&gt; &#123; private final static LongWritable account = new LongWritable(); private Text city = new Text(); private long startTime; @Override protected void setup(Context context)throws IOException,InterruptedException&#123; super.setup(context); startTime = System.currentTimeMillis(); &#125; @Override public void map(Object key,Text value, Context context) throws IOException,InterruptedException&#123;// 此处的value是文档中的第一行文本数据 String msg = value.toString(); String[] list = msg.split(&quot;;&amp;&quot;;); city.set(list[7]); double myDouble = Double.parseDouble(list[6]); long myLong = (long)myDouble; account.set(myLong); context.write(city,account); &#125; protected void cleanup(Context context) throws IOException,InterruptedException &#123; super.cleanup(context); long endTime = System.currentTimeMillis(); long duration = endTime - startTime; System.out.println(&quot;;MapperTime : &quot;;+ duration+ &quot;;ms&quot;;);//获取map计算总时间 &#125; &#125; public static class myReduce extends Reducer&lt;Text,LongWritable,Text,LongWritable&gt; &#123; private LongWritable result = new LongWritable(); private long startTime; @Override protected void setup(Context context) throws IOException,InterruptedException&#123; super.setup(context); startTime = System.currentTimeMillis(); &#125; // 从这可以看出reduce处理的输入数据是&lt;key,value-list&gt;类型的键值对 public void reduce(Text key, Iterable&lt;LongWritable&gt; values, Context context) throws IOException,InterruptedException&#123; int sum = 0;// reduce 函数就是对列表value中的数值进行相加 for(LongWritable val : values) &#123; sum += val.get(); &#125; result.set(sum);// 将结果写入context context.write(key,result); &#125; @Override protected void cleanup(Context context) throws IOException,InterruptedException&#123; super.cleanup(context); long endTime = System.currentTimeMillis(); long duration = endTime - startTime; System.out.println(&quot;;ReducerTime :&quot;;+duration+&quot;; ms&quot;;);//获取reduce计算总时间 &#125; &#125; /** * 1、accountByCity的main函数 * 2、main函数主要创建一个job对象，然后对accountBycity任务所需要的map函数，reduce函数，输入文件路径，输出文件路径的信息 * 进行配置 */ public static void main(String[] args) throws Exception&#123; Configuration conf = new Configuration(); Job job = Job.getInstance(conf,&quot;;;accountByCity&quot;;);//获取一个任务实例 job.setJarByClass(accountByCity.class);//设置工作类 job.setMapperClass(myMapper.class);//设置Mapper类 job.setReducerClass(myReduce.class);//设置Reduce类 job.setOutputKeyClass(Text.class);//设置输出键值对中的key的类型 job.setOutputValueClass(LongWritable.class);//设置输出键值对中value的类型 FileInputFormat.addInputPath(job,new Path(args[0]));//设置输入文件的路径 FileOutputFormat.setOutputPath(job,new Path(args[1])); FileSystem fs = FileSystem.get(conf);//获取HDFS文件系统 fs.delete(new Path(args[1]),true);//删除输出路径下可能已经存在的文件 运行项目首先启动Hadoop服务start-all.sh 上传日志文件到Hadoop的hdfs文件关系系统关于Hadoop shell指令上传日志文件 假设这是我的日志文件路径/hadoop/test hadoop fs -mkdir /data创建一个data目录 hadoop fs -mkdir /output创建一个output目录 hadoop fs -put /hadoop/test /data上传文件到data目录下 idea构建项目 执行项目—success map 100% reduce 100% 说明运行成功 12345678......23በ቞ 22:57:00 INFO mapred.LocalJobRunner: Finishing task: attempt_local524911839_0001_r_000000_023በ቞ 22:57:00 INFO mapred.LocalJobRunner: reduce task executor complete.23በ቞ 22:57:01 INFO mapreduce.Job: map 100% reduce 100%23በ቞ 22:57:01 INFO mapreduce.Job: Job job_local524911839_0001 completed successfully23በ቞ 22:57:01 INFO mapreduce.Job: Counters: 35...... 查看生成数据","categories":[],"tags":[{"name":"bigdata","slug":"bigdata","permalink":"https://q7df1.github.io/tags/bigdata/"}]},{"title":"音频转文字-openAI-Audio","slug":"音频转文字-openAI-Audio","date":"2023-03-09T12:19:45.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/03/09/音频转文字-openAI-Audio/","link":"","permalink":"https://q7df1.github.io/2023/03/09/%E9%9F%B3%E9%A2%91%E8%BD%AC%E6%96%87%E5%AD%97-openAI-Audio/","excerpt":"","text":"音频转文字书接上回，AI图片生成，问答生成，接下来博主继续介绍 openAI的音频转换API，实现音频提取并翻译(-&gt;English)文字 1、 准备环境 1、python基本环境 2、pip install openai(下载第三方库,改库来自openAI官方) 3、拥有openAI账号(chatGPT账号，没有可以注册一个) 4、具有代理上网能力(全局),或者挂在境外服务器上运行 2、实践首先进入openAI_API的官网获取API_Key—&gt;openAI 进入View API keys 点击创建Create new secret key 并复制所创建的API_Key备用 博主依旧是润色官网代码实现功能： 1、提取文字(不翻译) 12345678# Note: you need to be using OpenAI Python v0.27.0 for the code below to workimport openaiopenai.api_key = &quot;your API_Key&quot;audio_file= open(&quot;./demo2.mp3&quot;, &quot;rb&quot;) #路径修改为你的音频文件路径# 音频转化为文字response = openai.Audio.transcribe(&quot;whisper-1&quot;, audio_file)print(response[&#x27;text&#x27;]) 2、提取文字并翻译为英文 12345678# Note: you need to be using OpenAI Python v0.27.0 for the code below to workimport openaiopenai.api_key = &quot;your API_Key&quot;audio_file= open(&quot;./demo2.mp3&quot;, &quot;rb&quot;) #路径修改为你的音频文件路径# 音频转化为文字并翻译为英文response = openai.Audio.translate(&quot;whisper-1&quot;,audio_file)print(response[&#x27;text&#x27;]) 3、运行截图 4、总结相比于图形生成其效果还可以，也许适用于做短视频的字幕生成。 大家对AI感兴趣的可以阅读官方文档—&gt;openAI_Doc 值得注意的是使用API并不是免费的，每分钟的音频计费$0.006，但每个账户都有$18的额度","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://q7df1.github.io/tags/AI/"}]},{"title":"调用openAI API 实现AI画图","slug":"调用openAI-Image-models的API","date":"2023-03-08T16:42:34.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/03/09/调用openAI-Image-models的API/","link":"","permalink":"https://q7df1.github.io/2023/03/09/%E8%B0%83%E7%94%A8openAI-Image-models%E7%9A%84API/","excerpt":"","text":"调用openAI-Image models的API调用openAI-Image models的API 博主这里承接上文调用chatGPT的API实现AI对话，接着继续用API实现AI画图 依旧用Python代码实现 1、 准备环境 1、python基本环境 2、pip install openai(下载第三方库,改库来自openAI官方)、pip install requests 3、拥有openAI账号(chatGPT账号，没有可以注册一个) 4、具有代理上网能力(全局),或者挂在境外服务器上运行 2、实践首先进入openAI_API的官网获取API_Key—&gt;openAI 进入View API keys 点击创建Create new secret key 并复制所创建的API_Key备用 博主这里从官网直接复制代码，并添加了存储本地功能: 12345678910111213141516171819202122232425262728293031import openaiimport osimport requestsdef image(prompt): openai.api_key = &#x27;你自己的API_Key&#x27; response = openai.Image.create( prompt=prompt, n=1, size=&quot;1024x1024&quot; ) image_url = response[&#x27;data&#x27;][0][&#x27;url&#x27;] # 存储图片 fileDown(image_url)def fileDown(url): if not os.path.exists(&#x27;./image&#x27;): os.mkdir(&#x27;./image&#x27;) headers=&#123; &quot;User-Agent&quot;:&quot;Mozilla/5.0(Windows NT 10.0;Win64;x64) AppleWebKit / 537.36(KHTML, likeGecko) Chrome / 88.0.4324.150 Safari / 537.36&quot; &#125; res = requests.get(url=url,headers=headers).content src_path = &#x27;./image/&#x27; +url.split(&#x27;/&#x27;)[-1]+ &#x27;.jpg&#x27; with open(src_path,&#x27;wb&#x27;) as fp: fp.write(res)if __name__ == &quot;__main__&quot;: prompt = input(&#x27;请输入描述信息：&#x27;) print(&#x27;请稍后...&#x27;) image(prompt=prompt) print(&#x27;完成，请移步当前目录下image文件...&#x27;) 3、运行结果截图 效果如大家所见，就是难以形容，大家可以自己尝试一下！！！ 大家对AI感兴趣的可以阅读官方文档—&gt;openAI_Doc 值得注意的是使用API并不是免费的，每张1024*1024的图片花费 $0.020，但每个账户都有$18的额度","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://q7df1.github.io/tags/AI/"}]},{"title":"调用GPT-3.5-turbo的API","slug":"调用GPT-3-5-turbo的API","date":"2023-03-07T17:37:11.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/03/08/调用GPT-3-5-turbo的API/","link":"","permalink":"https://q7df1.github.io/2023/03/08/%E8%B0%83%E7%94%A8GPT-3-5-turbo%E7%9A%84API/","excerpt":"","text":"调用chatGPT的API(GPT-3.5-turbo)博主在这里用python编写代码的方式实现调用GPT-3.5-turbo的API实现终端访问chatGPT 1、 准备环境 1、python基本环境 2、pip install openai(下载第三方库,改库来自openAI官方) 3、拥有openAI账号(chatGPT账号，没有可以注册一个) 4、具有代理上网能力(全局),或者挂在境外服务器上运行 2、实践首先进入openAI_API的官网获取API_Key—&gt;openAI 进入View API keys 点击创建Create new secret key 并复制所创建的API_Key备用 博主这里从官网直接复制并添加润色了以下代码: 1234567891011121314# Note: you need to be using OpenAI Python v0.27.0 for the code below to workimport openaiopenai.api_key = &#x27;你的API&#x27;response = openai.ChatCompletion.create( model=&quot;gpt-3.5-turbo&quot;, messages=[ # &#123;&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: &quot;You are a helpful assistant.&quot;&#125;, &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Who are you?&quot;&#125;,#这里content表示输入问题 # &#123;&quot;role&quot;: &quot;assistant&quot;, &quot;content&quot;: &quot;The Los Angeles Dodgers won the World Series in 2020.&quot;&#125;, # &#123;&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: &quot;Where was it played?&quot;&#125; ])print(response[&#x27;choices&#x27;][0][&#x27;message&#x27;][&#x27;content&#x27;]) 3、结果显示打印类似如下内容说明成功！ 1As an AI language model developed by OpenAI, I am not a person or a human being. I am a computer program designed to understand and generate natural language responses to interact with humans. 大家对AI感兴趣的可以阅读官方文档—&gt;openAI_Doc 值得注意的是使用API并不是免费的，但每个账户都有US$ 18的额度 参考视频—&gt; TechDIYLife","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://q7df1.github.io/tags/AI/"}]},{"title":"申请SSL证书","slug":"申请SSL证书","date":"2023-03-05T16:18:31.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/03/06/申请SSL证书/","link":"","permalink":"https://q7df1.github.io/2023/03/06/%E7%94%B3%E8%AF%B7SSL%E8%AF%81%E4%B9%A6/","excerpt":"","text":"服务器申请SSL证书什么是SSL证书?chatGPT给出这样的答案： 对于普通人理解SSL证书可以这样：很简单，如果你的服务器拥有SSL证书，这样你部署的网站可以通过https(更安全)访问，否则只能通过http访问 事实上我们选择申请SSL证书目的是需要搭建VPS，搭建自己的面板时候需要SSL证书，那这里呢 博主就介绍一种免费申请SSL证书的方式:acme.sh脚本搭建 什么是acme.sh?chatGPT给出这样的答案： 实际操作基本环境：1、Linux操作系统(ubuntu/debain,centOS) 2、域名 实践：1、域名DNS记录/绑定指定vps(云服务器)ip 我这里使用cloudFlare绑定指定ip，（如果有需要的话）可以选择多绑定几个 值得注意的是：域名(domain)由两部分组成，顶级域名和二级域名 例如 www. example.com，这里example. com是顶级域名，也就是你自己所购买的域名，www是二级域名，再比如我的demo . example . com，我这里的名称即是demo即是二级域名，下面要填写域名操作要把一级域名和二级域名全部加上（demo . example . com） 2、Linux环境更新 123apt update -y #Debian/Ubuntu 命令apt install -y curl #Debian/Ubuntu 命令apt install -y socat #Debian/Ubuntu 命令 123yum update -y #CentOS 命令yum install -y curl #CentOS 命令yum install -y socat #CentOS 命令 2、安装 Acme 脚本 1curl https://get.acme.sh | sh 3、注册Acme 1~/.acme.sh/acme.sh --register-account -m xxxx@xxxx.com #后面是你的个人邮箱 4、更换服务器 1~/.acme.sh/acme.sh --issue -d demo.example.com --dns dns_cf --server letsencrypt 5、申请SSL 1~/.acme.sh/acme.sh --issue -d demo.example.com --standalone -k ec-256 出现以下信息则说明已经申请成功！ 前两行分别是证书公钥和密钥地址，要用到SSL证书直接复制其地址即可 最后祝你好运！！！ 参考资料波仔分享 一瓶奶油","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://q7df1.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"国内注册chatGPT","slug":"国内注册chatGPT","date":"2023-02-13T11:29:54.000Z","updated":"2023-07-09T14:22:18.000Z","comments":true,"path":"2023/02/13/国内注册chatGPT/","link":"","permalink":"https://q7df1.github.io/2023/02/13/%E5%9B%BD%E5%86%85%E6%B3%A8%E5%86%8CchatGPT/","excerpt":"","text":"国内注册GPT基本步骤扫盲简要步骤及条件 国外IP(博主选择的USA) 邮箱(不受限制) 国外电话号码(靠接码平台) 如果你1和3步没有的话预计要花费20RMB！！！ 代理IP这里不赘述如何获取国外IP，你可以理解为翻墙，挂梯子，代理上网，科学上网，最好是原生国外ip这里博主使用的USA的ip，注册账号没有压力，我不会推荐你去购买代理ip也不会提供任何有关代理ip的信息，这一切都得由你自己钻研，加油！！！提供一个网站，如果你开启了代理ip的话这里可以显示你的代理位置 whoer. 此外，不单单注册需要代理ip，正常使用也需要，故不是真正觉得需要，或者已经具备条件，没必要尝试（劝退） 邮箱邮箱的话没有什么特别的要求国内的QQ和163都可以用，博主用的outlook邮箱，但个人认为这个邮箱不太好(很多时候收不到邮件，或者很慢)，有gmail或者其他正常邮箱都可以使用： 国外电话验证此步骤需要验证国外电话号码，值得注意的是包括中国本土号码还有好几个国家也是没有chatGPT服务的，但是不用担心，一般找个靠谱的国外接码平台（这类平台提供各种注册账号需要的各国电话号码，利用好他们可以突破各种限制注册很多不在本土服务的账号）即可，这里不推荐任何接码平台，需要的可自行搜索寻找，你可以利用你的国外ip代理访问Google搜索，找个价格能接受,靠谱的网站，一般是通过充值一定金额，博主用过两个。一个支付宝充值了5美刀也就是人民币35元左右，但只用了1美刀的样子，剩下的金额就在账户里下次备用。另一个一次充值只需要一美刀，基本上也用完了 步骤进入网站注册ChatGPT 选择 Sign up 输入邮箱简单填好身份信息此过程很简单按流程来即可 手机验证这里需要用到接码平台，前面我已经讲清楚了，原理也很简单，看你自己能否找到并利用 成功！！！ 祝你好运！！！","categories":[],"tags":[{"name":"AI","slug":"AI","permalink":"https://q7df1.github.io/tags/AI/"}]},{"title":"接口实现多态","slug":"接口实现多态","date":"2023-02-06T06:59:36.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/02/06/接口实现多态/","link":"","permalink":"https://q7df1.github.io/2023/02/06/%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81/","excerpt":"","text":"接口使得程序更具有灵活性和拓展性的主要原因是它实现了多态性。多态性指的是不同的类型可以实现相同的接口，并可以通过接口类型访问这些实现。 通过实现接口，不同的类型可以共享相同的行为，使得程序变得更加灵活和可拓展。例如，您可以定义一个绘制图形的接口，并且所有图形类型（如矩形、圆形、三角形等）都可以实现该接口。这使得您可以在不知道具体图形类型的情况下使用这些图形。 另外，接口还允许您在不修改已有代码的情况下添加新的功能。例如，您可以添加一个新的类型，它实现了接口中的方法，从而扩展了程序的功能。这种方式的好处是，您不需要修改现有代码，并且原有代码仍然可以正常使用。 因此，接口可以使得程序更具灵活性和拓展性，使代码更加简洁和易于维护。 阅读一下代码 12345678910111213141516171819202122232425262728293031323334353637383940package mainimport ( &quot;fmt&quot; &quot;math&quot;)//接口，包含一个计算面积方法，返回值float64类型type Shape interface &#123; Area() float64&#125;//长方形type Rectangle struct &#123; width float64 height float64&#125;//计算长方行的面积方法func (r Rectangle) Area() float64 &#123; return r.height * r.width&#125;//圆type Circle struct &#123; radius float64&#125;//计算圆面积方法func (c Circle) Area() float64 &#123; return math.Pi * c.radius * c.radius&#125;//此方法打印面积func PrintArea(s Shape)&#123; fmt.Println(s.Area())&#125;func main() &#123; r := Rectangle&#123;width: 10, height: 20&#125; c := Circle&#123;radius: 2&#125;//不同图形用相同方法 PrintArea(r) PrintArea(c)&#125; 这段代码中定义了两个类：长方形和圆，并且分别计算这两种图形型的面积","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://q7df1.github.io/tags/Golang/"}]},{"title":"搭建cs起源服务器","slug":"搭建cs起源服务器","date":"2023-01-14T16:13:59.000Z","updated":"2023-07-09T14:22:16.000Z","comments":true,"path":"2023/01/15/搭建cs起源服务器/","link":"","permalink":"https://q7df1.github.io/2023/01/15/%E6%90%AD%E5%BB%BAcs%E8%B5%B7%E6%BA%90%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"","text":"欢迎来学习搭建cs起源，搭建cs服务器主要分为三部分： 1、服务器选择 2、steamcmd安装 3、登录并安装CS起源服务器 注意：在这里，我默认了你有Linux基础，能够看懂并处理一些问题 Quick Start一、选择一款合适的轻量级服务器。我选择的是国内轻量级云服务器，各大商家其实卖的都不贵，大家可以去多对比，选择折扣力度最大的，也可以先找个免费的试试水。一定要选择国内的服务器，毕竟作为游戏服务器延迟太高懂得都懂，除非你在国外，那选择你自己所在区域就好了。 操作系统选择：Centos或Ubuntu或Debian这些都可以，区别有一点点但是不大这里我选择的是CentOS7.6然后Ubuntu和Debian因为同根所以方法也是相同的 当然也可以用docker安装，而且更加方便有兴趣的小伙伴，我会将官网地址贴在最后面 登录方式：我选择的xshell这款工具，其他工具一样开放端口：一定要在服务器厂商那-&gt;控制台-&gt;防火墙-&gt;添加规则，开放端口，默认27015（TCP和UDP都开放）二、steamcmd安装首先连接到Linux系统后首先创建个steam用户 1useradd -m steam 进入用户目录 1cd /home/steam 以上步骤各个Linux操作系统相同 接下来我会分操作系统打印命令 CentOS安装：安装环境：若你的操作系统不是64位，那只需要执行上面这条 1yum install glibc libstdc++ 1yum install glibc.i686 libstdc++.i686 CentOS安装screen管理工具1yum install -y screen Ubuntu&#x2F;Debain安装:环境安装注意：root用户不用加sudo 1sudo apt-get install lib32gcc1 Ubuntu&#x2F;Debain安装screen管理工具1sudo apt-get install screen 注意：以下操作相同 切换用户：默认以root用户登录切换到steam用户 1su - steam 为 SteamCMD 创建目录并切换至该目录。 1mkdir ~/Steam &amp;&amp; cd ~/Steam 下载并解压缩适用于 Linux 的 SteamCMD。 1curl -sqL &quot;https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz&quot; | tar zxvf - ls查看一下是不是有个steamcmd.sh文件，并运行 1ls 1./steamcmd.sh 吐槽一句:第一次加载可能有点慢，看运气，如果下载实在很慢的话可以ctrl＋c退出，然后将整个Steam文件夹干掉（删除）然后会到前面创建Steam文件那重来就好 三、登录steamcmd并安装CS起源如果出现Steam&gt;这个就证明你成功安装了，接下来在这个界面我们要登录，并安装cs起源 注意：在Steam&gt;里面不小心输入错了也删不了的话，没关系，回车一下再重新输入就好 选择路径:1force_install_dir ./cs_source/ 登录SteamCMD：注意：要先选择路径后登录 这里采用匿名方式登录,省事 1login anonymous 下载cs起源服务器：1app_update 232330 validate 然后你只需要等待，或者泡杯茶，或者先去打开steam准备测试 这个下载速度客观，而且不会像cs1.6那样报错 等他出现Success! App &#39;232330&#39; fully installed.就输入quit 配置文件：现在就已经完成cs起源安装了 接下来需要稍稍配置一下就好了,将一下内容复制粘贴到一个文本文件内容，然后重命名为server.cfg上传到目录/home/steam/Steam/cs_source/cstrike/cfg中，当然这是我的目录，如果你前面有更改的话会不同，但核心就是将文件放入cstrike下面的cfg文件中 123456789101112131415161718192021222324252627282930313233343536373839404142hostname &quot;全CS区最靓的服务器&quot; //服务器的名称Rcon_password &quot;&quot; // 远程控制密码, 没设即不需要密码sv_password &quot;&quot; // 进入服务器所需的密码设定, 没设即不需要密码sv_region &quot;4&quot; // 设定服务器的所在区域, 4 为亚洲sv_allowdownload &quot;1&quot; // 允许下载档案 (如: 新地图)sv_allowupload &quot;1&quot; // 允许上传档案sv_alltalk &quot;0&quot; // 公麦 (0/1 - 关/开)sv_cheats &quot;0&quot; //作弊功能tv_enable &quot;1&quot; // 开启 Source TV (0/1 - 关/开)sv_downloadurl &quot;http://css.xxx.com/&quot; //设置地图下载，域名需要绑定在 cstrike 目录上，否则将无法下载地图，可以把地图压缩城.b2z格式提高下载速度sv_gravity &quot;800&quot; // 地心引力设定值, 预设 800 重力sv_voiceenable &quot;1&quot; // 是否允许玩家使用 mic (0/1 - 关/开)sv_rcon_maxfailures &quot;2&quot; //试图取得治理员权限失败凌驾几次，CDKEY即被BANsv_maxrate &quot;0&quot; //限制网络传输的资料最大值sv_minrate &quot;0&quot; //限制网络传输的资料最小值sv_maxupdaterate &quot;66&quot; //服务器发送至客户端的最大每秒更新次数sv_minupdaterate &quot;66&quot; //服务器发送至客户端的最小每秒更新次数mp_playerid &quot;0&quot; // 是否显示敌人及队友名字, 1:不显示敌人 2:皆不显示mp_flashlight &quot;1&quot; // 是否允许手电筒 (0/1 - 关/开)mp_timelimit &quot;0&quot; //多少时间后换地图mp_maxrounds &quot;0&quot; //多少回合后换地图4mp_allowspectators &quot;1&quot; // 是否允许观察者 (0/1 - 关/开) mp_footsteps &quot;1&quot; // 是否允许脚步声 (0/1 - 关/开)mp_falldamage &quot;1&quot; // 高处落下杀伤mp_autokick &quot;0&quot; // 是否将闲置及TKer自动踢出服务器 (0/1 - 关/开)mp_startmoney &quot;16000&quot; //开局金钱设置mp_winlimit &quot;0&quot; //任意一队杀多少回合后换地图mp_fraglimit &quot;0&quot; // 某玩家获得多少 frag 后换地图 (0 无限制) mp_freezetime &quot;0&quot; // 回合开始前的冻结时间 (单位: 秒, 0 为无冻结时间) mp_buytime &quot;0.25&quot; //设置购买武器的时间（单位秒）mp_forcecamera &quot;0&quot; // 玩家死后是否只能看到同队画面 (0/1 - 关/开) mp_fadetoblack &quot;0&quot; // 玩家死后画面是否为黑幕 (0/1 - 关/开) mp_friendlyfire &quot;0&quot; //设定会不会杀伤队友。1是会，0是关闭mp_autoteambalance &quot;1&quot; // 是否启动自动队伍平衡功能 (0/1 - 关/开) mp_limitteams &quot;1&quot; // 队伍人数最大可相差几人 mp_roundtime &quot;3&quot; // 回合时间 (单位: 分钟) log &quot;0&quot; //设定是否启用日志 0 不启用 1启用mp_logdetail &quot;0&quot; // 是否启用详细 log 功能 (0/1 - 关/开mp_tkpunish &quot;0&quot; // 是否开启 TK 惩罚 (0/1 - 关/开) mp_c4timer &quot;35&quot; //C4炸弹引爆时间sv_airaccelerate &quot;5&quot; //空中停留时间 (默认 10)sv_enablebunnyhopping &quot;0&quot; //是否开启连跳相关 启动服务器进入目录 1/home/steam/Steam/cs_source 创建一个启动脚本（如果报错显示没有vim可以用vi代替） 1vim strat.sh 输入i进入插入模式并粘贴脚本 123456#!/bin/shecho &quot;Starting CS:Source Server&quot;sleep 1screen -A -dm -S css-server ./srcds_run -console -game cstrike -tickrate 66 -pingboost 3 +sv_lan 0 -port 27015 +map de_inferno +maxplayers 10screen -x css-server 可以更改脚本内容，我这里是最大十个玩家，然后地图是小镇，你可以修改成自己想要比如de_dust_2 启动后键盘Ctrl+a+d，这样我们就可以安心退出，程序会执行下去 可以通过screen -ls 命令查看会话窗口 也可以用ps -u查看进程，关闭的话用kill PID 连接服务器：进入cs起源后~键打开控制台 输入 1connect 你的ip 改端口了的话要加端口号 1connect 你的ip:端口号 四、参考文档:官方文档 1https://developer.valvesoftware.com/wiki/SteamCMD:zh-cn","categories":[],"tags":[{"name":"服务器","slug":"服务器","permalink":"https://q7df1.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"}]},{"title":"Hello World","slug":"hello-world","date":"2023-01-14T13:07:32.000Z","updated":"2023-01-14T13:07:32.000Z","comments":true,"path":"2023/01/14/hello-world/","link":"","permalink":"https://q7df1.github.io/2023/01/14/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://q7df1.github.io/tags/Java/"},{"name":"硬件","slug":"硬件","permalink":"https://q7df1.github.io/tags/%E7%A1%AC%E4%BB%B6/"},{"name":"bigdata","slug":"bigdata","permalink":"https://q7df1.github.io/tags/bigdata/"},{"name":"AI","slug":"AI","permalink":"https://q7df1.github.io/tags/AI/"},{"name":"服务器","slug":"服务器","permalink":"https://q7df1.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"Golang","slug":"Golang","permalink":"https://q7df1.github.io/tags/Golang/"}]}